#!/usr/bin/env bash
#
# Perform a network scan to discover hosts on the network.
#
# Version: v1.0.7
# License: MIT License
#          Copyright (c) 2024 Hunter T. (StrangeRanger)
#
########################################################################################
####[ Script Wide Variables ]###########################################################


yellow="$(printf '\033[1;33m')"
green="$(printf '\033[0;32m')"
blue="$(printf '\033[0;34m')"
cyan="$(printf '\033[0;36m')"
red="$(printf '\033[1;31m')"
nc="$(printf '\033[0m')"
clrln="$(printf '\r\033[K')"

tempfile=""
max_concurrent_pings=255
lower_bound=""
upper_bound=""
background_jobs=()


####[ Functions ]#######################################################################


####
# Display the usage of the script.
#
# Parameters:
#   - $1: flag (Optional)
#       - Description: Display the verbose usage of the script.
#       - Options: "-v"
####
usage() {
    local flag="$1"

    if [[ $flag == "-v" ]]; then
        echo "Perform a network scan across a range of IP addresses to discover hosts on the network."
    fi

    echo ""
    echo "Usage: ${0##*/} <starting IP> <ending IP>"
}

####
# Verify if the provided IP address is valid.
#
# Parameters:
#   - $1: ip (Required)
#       - Description: The IP address to verify.
####
verify_valid_ip() {
    local ip="$1"
    local valid_ip_regex="^((25[0-5]|2[0-4][0-9]|1?[0-9][0-9]?)\.){3}(25[0-5]|2[0-4][0-9]|1?[0-9][0-9]?)$"

    if [[ ! $ip =~ $valid_ip_regex ]]; then
        echo -e "${red}ERROR:${nc} Invalid IP address: $1"
        clean_exit "1"
    fi
}

####
# Check the lower and upper bounds of the IP addresses.
#
# Parameters:
#   - $1: bound_one (Required)
#       - Description: The first IP address to compare.
#   - $2: bound_two (Required)
#       - Description: The second IP address to compare.
####
check_lower_upper_bounds() {
    local bound_one="$1"
    local bound_two="$2"

    if [[ $(ip_to_int "$bound_one") -gt $(ip_to_int "$bound_two") ]]; then
        lower_bound="$bound_two"
        upper_bound="$bound_one"
    else
        lower_bound="$bound_one"
        upper_bound="$bound_two"
    fi
}

####
# Convert an IP address to an integer.
#
# Parameters:
#   - $1: ip (Required)
#       - Description: The IP address to convert to an integer.
####
ip_to_int() {
    local ip="$1"
    local IFS='.'

    read -r octet1 octet2 octet3 octet4 <<< "$ip"
    echo $(( (octet1 << 24) + (octet2 << 16) + (octet3 << 8) + octet4 ))
}

####
# Convert an integer to an IP address.
#
# Arguments:
#   - $1: ip_int (Required)
#       - Description: The integer to convert to an IP address.
####
int_to_ip() {
    local ip_int="$1"
    echo "$((ip_int >> 24 & 255)).$((ip_int >> 16 & 255)).$((ip_int >> 8 & 255)).$((ip_int & 255))"
}

####
# Handles the cleanup process when the script exits. This function is designed to be
# triggered on normal exits, errors, or interruptions.
#
# Parameters:
#   - $1: exit_code (Required)
#       - Description: The type of exit that occurred.
#       - Acceptable values:
#           - 0: Normal exit. The script completed its task successfully.
#           - 1: Exiting due to an error. An error occurred during the script execution.
#           - 130: User interruption. The user interrupted the script using Ctrl+C.
#           - 143: User interruption. The user interrupted the script using kill.
#   - $2: clean_up (Optional)
#       - Description: Whether to perform cleanup operations.
#       - Acceptable values: "true" or "false"
#       - Default: "true"
####
clean_exit() {
    local exit_code="$1"
    local clean_up="$2:-true"

    if [[ $exit_code == "1" ]]; then
        echo "${red}==>${nc} A fatal error occurred."
    elif [[ $exit_code == "130" ||  $exit_code == "143" ]]; then
        echo ""
        echo "${yellow}==>${nc} User interruption detected."
    fi

    if [[ $clean_up == "true" ]]; then
        echo "${cyan}==>${nc} Cleaning up..."

        for job in "${background_jobs[@]}"; do
            kill -9 "$job" > /dev/null 2>&1
        done

        [[ -f "$tempfile" ]] && rm "$tempfile"
    fi

    exit "$exit_code"
}


####[ Error Traps ]#####################################################################
#### This section sets up error traps to ensure that the script exits gracefully.


trap 'clean_exit "130"' SIGINT
trap 'clean_exit "143"' SIGTERM


####[ Verification ]####################################################################
#### This section ensures that certain conditions are met before the script continues.


if [[ $# -eq 0 ]]; then
    usage "-v"
    clean_exit "0" "false"
fi

if [[ $# -ne 2 ]]; then
    echo -e "${red}ERROR:${nc} Invalid number of arguments."
    usage
    clean_exit "1" "false"
fi

verify_valid_ip "$1"
verify_valid_ip "$2"
check_lower_upper_bounds "$1" "$2"


####[ Main Script ]#####################################################################
########[[ Main Variables ]]############################################################


starting_point=$(ip_to_int "$lower_bound")
ending_point=$(ip_to_int "$upper_bound")
total_ips=$((ending_point - starting_point + 1))
tempfile=$(mktemp)
iteration_count=0
current_pings=0


########[[ Perform Network Scan ]]######################################################


echo "${cyan}==>${nc} Performing network scan to discover hosts on the network..."

for ((ip_int = starting_point; ip_int <= ending_point; ip_int++)); do
    ip=$(int_to_ip "$ip_int")

    (( iteration_count += 1 ))
    echo -en "$clrln"
    echo -en "${blue}==>${nc} Scanning IP address: $ip ($iteration_count/$total_ips)\r"

    # Run ping in the background
    (
        ping -c 1 -W 1 "$ip" > /dev/null 2>&1 \
            && { echo -e "${clrln}${green}==>${nc} Found valid IP address: $ip";
                 echo "$ip" >> "$tempfile";
            }
    )&
    background_jobs+=($!)

    # Increment the count of current background pings.
    ((current_pings++))

    # If the number of current pings reached the limit, wait for all to complete.
    if [[ $current_pings -eq $max_concurrent_pings ]]; then
        wait  # Wait for all background jobs to finish.
        current_pings=0  # Reset the current pings counter.
    fi
done

# Wait for any remaining background jobs to complete.
wait

echo ""
echo "${cyan}==>${nc} Network scan complete."


########[[ Display Results ]]###########################################################


# Count valid IP addresses
ip_addr_count=$(wc -l < "$tempfile")

if [[ $ip_addr_count -eq 0 ]]; then
    echo "${yellow}==>${nc} No valid IP addresses found."
else
    echo "${green}==>${nc} Found $ip_addr_count valid IP addresses:"
    cat "$tempfile"
fi

clean_exit "0"
