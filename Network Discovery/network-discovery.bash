#!/usr/bin/env bash
#
# Perform a ping scan to discover existing hosts on the network.
#
# Version: v1.0.12
# License: MIT License
#          Copyright (c) 2024 Hunter T. (StrangeRanger)
#
########################################################################################
####[ Global Variables ]################################################################


background_jobs=()
ip_addresses_pinged=0
current_concurrent_pings=0

###
### [ Configurable Variables ]
### NOTE: The following variables can be modified to suit your needs.
###

# The maximum number of concurrent pings to run.
readonly C_MAX_CONCURRENT_PINGS=255

###
### [ Constants ]
###

## Variables to colorize the output.
C_YELLOW="$(printf '\033[1;33m')"
C_GREEN="$(printf '\033[0;32m')"
C_BLUE="$(printf '\033[0;34m')"
C_CYAN="$(printf '\033[0;36m')"
C_RED="$(printf '\033[1;31m')"
C_NC="$(printf '\033[0m')"
C_CLRLN="$(printf '\r\033[K')"
readonly C_YELLOW C_GREEN C_BLUE C_CYAN C_RED C_NC C_CLRLN


####[ Functions ]#######################################################################


####
# Display a script usage message.
#
# PARAMETERS:
#   - $1: flag (Optional, Default: "")
#       - Display the verbose usage of the script.
#       - Acceptable values:
#           - "-v"
usage() {
    local flag="$1"

    if [[ $flag == "-v" ]]; then
        echo "Perform a network scan across a range of IP addresses to discover hosts" \
            "on the network."
    fi

    echo ""
    echo "Usage: ${0##*/} <starting IP> <ending IP>"
}

####
# Verify if the provided IP address is valid, based on a regular expression pattern.
#
# GLOBALS:
#   - C_RED : Set text color to red.
#   - C_NC : Reset text color.
#
# PARAMETERS:
#   - $1: ip (Required)
#       - The IP address to verify.
verify_valid_ip() {
    local ip="$1"
    local valid_ip_regex="^((25[0-5]|2[0-4][0-9]|1?[0-9][0-9]?)\.){3}(25[0-5]|2[0-4][0-9]|1?[0-9][0-9]?)$"

    if [[ ! $ip =~ $valid_ip_regex ]]; then
        echo -e "${C_RED}ERROR:${C_NC} Invalid IP address: $ip" >&2
        clean_exit "1" "" "false"
    fi
}

####
# Given two IP addresses, determine the lower and upper bounds, and store them in the in
# the global variables $C_LOWER_BOUND and $C_UPPER_BOUND.
#
# GLOBALS:
#   - C_RED : Set text color to red.
#   - C_NC : Reset text color.
#
# NEW GLOBALS:
#   - C_LOWER_BOUND : Initialized for external use.
#       - Indicates the *start* of the IP range to be scanned.
#   - C_UPPER_BOUND : Initialized for external use.
#       - Indicates the *end* of the IP range to be scanned.
#
# PARAMETERS:
#   - $1: bound_one (Required)
#       - The first IP address to compare.
#   - $2: bound_two (Required)
#       - The second IP address to compare.
check_lower_upper_bounds() {
    local bound_one="$1"
    local bound_two="$2"

    if (( $(ip_to_int "$bound_one") > $(ip_to_int "$bound_two") )); then
        C_LOWER_BOUND="$bound_two"
        C_UPPER_BOUND="$bound_one"
    elif (( $(ip_to_int "$bound_one") < $(ip_to_int "$bound_two") )); then
        C_LOWER_BOUND="$bound_one"
        C_UPPER_BOUND="$bound_two"
    else
        echo -e "${C_RED}ERROR:${C_NC} The lower and upper bounds are the same." >&2
        clean_exit "1" "" "false"
    fi
}

####
# Convert a given IP address into an integer.
#
# NOTE:
#   This allows for easier IP address comparison and calculation. Specifically, the
#   integer is used to calculate the range of IP addresses to scan, among other things.
#
# PARAMETERS:
#   - $1: ip (Required)
#       - The IP address to convert to an integer.
ip_to_int() {
    local ip="$1"
    local IFS='.'

    read -r octet1 octet2 octet3 octet4 <<< "$ip"
    echo "$(( (octet1 << 24) + (octet2 << 16) + (octet3 << 8) + octet4 ))"
}

####
# Convert an integer, back into an IP address.
#
# NOTE:
#   This function reverts the integer conversion back to an IP address, to ensure that
#   the IP address is displayed in the correct format.
#
# PARAMETERS:
#   - $1: ip_int (Required)
#       - The integer to convert to an IP address.
int_to_ip() {
    local ip_int="$1"
    echo "$((ip_int >> 24 & 255)).$((ip_int >> 16 & 255)).$((ip_int >> 8 & 255)).$((ip_int & 255))"
}

####
# Handles the cleanup process when the script exits normally or due to an error.
#
# NOTE:
#   This function is designed to be triggered on normal exits, errors, or interruptions.
#
# GLOBALS:
#   - background_jobs : Iterate over to kill all background jobs.
#   - C_TMP_FILE : Temporary file to remove.
#   - C_RED : Set text color to red.
#   - C_NC : Reset text color.
#   - C_YELLOW : Set text color to yellow.
#
# PARAMETERS:
#   - $1: exit_code (Required)
#       - The type of exit that occurred.
#       - Acceptable values:
#           - 0: Normal exit. The script completed its task successfully.
#           - 1: Exiting due to an error. An error occurred during the script execution.
#           - 130: User interruption. The user interrupted the script using Ctrl+C.
#           - 143: User interruption. The user interrupted the script using kill.
#   - $2: clean_up (Optional, Default: "true")
#       - Whether to perform cleanup operations.
#       - Acceptable values:
#           - "true": Perform cleanup operations.
#           - "false": Skip cleanup operations.
#   - $3: display_message (Optional, Default: "true")
#       - Whether to display fatal error or user interruption messages.
#       - Acceptable values:
#           - "true": Display the message.
#           - "false": Skip displaying the message.
clean_exit() {
    local exit_code="$1"
    local clean_up="${2:-true}"
    local display_message="${3:-true}"

    if [[ $exit_code == "1" && $display_message == "true" ]]; then
        echo "${C_RED}==>${C_NC} A fatal error occurred." >&2
    elif [[ ($exit_code == "130" ||  $exit_code == "143") \
            && $display_message == "true" ]]; then
        echo ""
        echo "${C_YELLOW}==>${C_NC} User interruption detected."
    fi

    if [[ $clean_up == "true" ]]; then
        echo "${C_CYAN}==>${C_NC} Cleaning up..."

        for job in "${background_jobs[@]}"; do
            kill -9 "$job" > /dev/null 2>&1
        done

        [[ -f "$C_TMP_FILE" ]] && rm "$C_TMP_FILE"
    fi

    exit "$exit_code"
}


####[ Error Traps ]#####################################################################
#### This section sets up error traps to ensure that the script exits gracefully.


trap 'clean_exit "130"' SIGINT
trap 'clean_exit "143"' SIGTERM


####[ Verification ]####################################################################
#### This section ensures that certain conditions are met before the script continues.


if [[ $# -eq 0 ]]; then
    usage "-v"
    clean_exit "0" "false"
fi

if [[ $# -ne 2 ]]; then
    echo -e "${C_RED}ERROR:${C_NC} Invalid number of arguments." >&2
    usage
    clean_exit "1" "false" "false"
fi

verify_valid_ip "$1"
verify_valid_ip "$2"
check_lower_upper_bounds "$1" "$2"


####[ Main Script ]#####################################################################
####[[ Main Variables ]]################################################################


C_STARTING_POINT=$(ip_to_int "$C_LOWER_BOUND")
C_ENDING_POINT=$(ip_to_int "$C_UPPER_BOUND")
C_TOTAL_IPS=$((C_ENDING_POINT - C_STARTING_POINT + 1))
C_TMP_FILE=$(mktemp)


####[[ Perform Network Scan ]]##########################################################


echo "${C_CYAN}==>${C_NC} Performing network scan to discover hosts on the network..."

for ((ip_int = C_STARTING_POINT; ip_int <= C_ENDING_POINT; ip_int++)); do
    ip=$(int_to_ip "$ip_int")

    (( ip_addresses_pinged += 1 ))
    echo -en "$C_CLRLN"
    echo -en "${C_BLUE}==>${C_NC} Scanning IP address: $ip" \
        "($ip_addresses_pinged/$C_TOTAL_IPS)\r"

    # Run ping in the background.
    (
        ping -c 1 -W 1 "$ip" > /dev/null 2>&1 \
            && echo -e "${C_CLRLN}${C_GREEN}==>${C_NC} Found valid IP address: $ip" \
            && echo "$ip" >> "$C_TMP_FILE"
    )&
    background_jobs+=($!)

    (( current_concurrent_pings++ ))

    ## If the number of current pings reached the limit, wait for all to complete.
    if [[ $current_concurrent_pings -eq $C_MAX_CONCURRENT_PINGS ]]; then
        wait  # Wait for all background jobs to finish.
        current_concurrent_pings=0  # Reset the current pings counter.
        background_jobs=()  # Reset the background jobs array.
    fi
done

# Wait for any remaining background jobs to complete.
wait

echo ""
echo "${C_CYAN}==>${C_NC} Network scan complete."


####[[ Display Results ]]###############################################################


# Count valid IP addresses
ip_addr_count=$(wc -l < "$C_TMP_FILE")

if (( ip_addr_count == 0 )); then
    echo "${C_YELLOW}==>${C_NC} No valid IP addresses found."
else
    echo "${C_GREEN}==>${C_NC} Found $ip_addr_count valid IP addresses"
fi

clean_exit "0"

